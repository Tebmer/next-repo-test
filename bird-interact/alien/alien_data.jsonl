{"instance_id": "1", "selected_database": "alien", "query": "I want to analyze how the Signal-to-Noise Quality Indicator (SNQI) varies across different weather conditions. For each weather condition, give weather condition name, the average SNQI, the median SNQI, and count how many analyzable signals there are. Sort the result by average SNQI in descending order.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": ["/* \nIntent: Analyze signal quality (SNQI) with atmospheric conditions using window functions\nKnowledge Used: SNQI (id:0)\nAdvanced Features: Window functions, conditional aggregation\n*/\nWITH signal_quality AS (\n    -- Step 1: Calculate SNQI for all signals with their observation conditions\n    SELECT \n        s.SignalRegistry,\n        s.SnrRatio - 0.1 * ABS(s.NoiseFloorDbm) AS SNQI,\n        o.WeathProfile\n    FROM Signals s\n    JOIN Telescopes t ON s.TelescRef = t.TelescRegistry\n    JOIN Observatories o ON t.ObservStation = o.ObservStation\n)\n-- Step 2: Rank signals by quality within weather profiles\nSELECT \n    WeathProfile,\n    AVG(SNQI) AS avg_snqi,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY SNQI) AS median_snqi,\n    COUNT(*) FILTER (WHERE SNQI > 0) AS analyzable_signals\nFROM signal_quality\nGROUP BY WeathProfile\nORDER BY avg_snqi DESC;"], "external_knowledge": [0, 50], "test_cases": [], "category": "Query", "high_level": true, "conditions": {"decimal": -1, "distinct": false}, "amb_user_query": "I want to analyze how the signal quality varies across different atmospheric conditions. For each condition, give condition name, the average quality value, the median quality value, and count how many usable signals there are. Sort the result by average value.", "user_query_ambiguity": {"critical_ambiguity": [{"term": "signal quality", "sql_snippet": "s.SnrRatio - 0.1 * ABS(s.NoiseFloorDbm) AS SNQI", "is_mask": true, "type": "knowledge_linking_ambiguity"}, {"term": "good signals", "sql_snippet": "COUNT(*) FILTER (WHERE SNQI > 0) as analyzable signals", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": [{"term": "order", "sql_snippet": "ORDER BY avg_snqi DESC", "is_mask": false, "type": "sort_ambiguity"}]}, "knowledge_ambiguity": [{"term": "Signal-to-Noise Quality Indicator (SNQI)", "sql_snippet": "s.SnrRatio - 0.1 * ABS(s.NoiseFloorDbm) AS SNQI", "is_mask": false, "type": "knowledge_ambiguity", "deleted_knowledge": 0}], "follow_up": {"query": "How does the Atmospheric Observability Index (AOI) vary across different weather conditions? For each weather condition, provide:\n\n- Weather condition name\n- Average AOI\n- Median AOI\n- Count of valid observations (AOI > 0)\n\nSorted by average AOI in descending order.", "sol_sql": "/*\nIntent: Analyze Atmospheric Observability Index (AOI) with weather conditions\nKnowledge Used: AOI (id:1)\nAdvanced Features: Window functions, conditional aggregation\n*/\n\nWITH observ_conditions AS (\n    -- Step 1: Calculate AOI for all signals with their observation conditions\n    SELECT \n        s.SignalRegistry,\n        o.AtmosTransparency * (1 - o.HumidityRate / 100) * (1 - 0.02 * o.WindSpeedMs) AS AOI,\n        o.WeathProfile\n    FROM \n        Signals s\n    JOIN \n        Telescopes t ON s.TelescRef = t.TelescRegistry\n    JOIN \n        Observatories o ON t.ObservStation = o.ObservStation\n)\n\n-- Step 2: Aggregate AOI metrics by weather profile\nSELECT \n    WeathProfile,\n    AVG(AOI) AS avg_aoi,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY AOI) AS median_aoi,\n    COUNT(*) FILTER (WHERE AOI > 0) AS valid_observations\nFROM \n    observ_conditions\nGROUP BY \n    WeathProfile\nORDER BY \n    avg_aoi DESC;", "external_knowledge": [1], "type": "attribute_change", "test_cases": [], "category": "Query"}}
{"instance_id": "2", "selected_database": "alien", "query": "Create a PostgreSQL function called 'calculate_disf' that computes the Detection Instrument Sensitivity Factor (DISF) and return the calculated value.", "preprocess_sql": [], "clean_up_sqls": [], "sol_sql": ["-- Create a function to calculate Detection Instrument Sensitivity Factor (DISF).\n-- Intent: Define a function that computes DISF using telescope environmental data and then test it.\n-- Step 1: Create the function \"calculate_disf\" using PL/pgSQL.\n--         Inputs: AirTempC, AtmosTransparency, HumidityRate, LunarDistDeg.\n--         Calculation: DISF = (10 - |AirTempC - 15|/10) * AtmosTransparency * (1 - HumidityRate/200) * ((100 - LunarDistDeg)/100)\n-- Knowledge Used:\n--   \"Detection Instrument Sensitivity Factor (DISF)\" [KB id:5] and advanced procedural language features.\nCREATE OR REPLACE FUNCTION calculate_disf(\n    p_airtemp NUMERIC, \n    p_trans NUMERIC, \n    p_humidity NUMERIC, \n    p_lunar_deg NUMERIC\n) RETURNS NUMERIC AS $$\nDECLARE\n    v_disf NUMERIC;\nBEGIN\n    -- Calculate the DISF based on the given formula.\n    v_disf := (10 - ABS(p_airtemp - 15)/10) * p_trans * (1 - p_humidity/200) * ((100 - p_lunar_deg)/100);\n    RETURN v_disf;\nEND;\n$$ LANGUAGE plpgsql;\n"], "external_knowledge": [5], "test_cases": ["\ndef test_case(pred_sqls, sol_sqls, db_name, conn):\n    # The expected DISF value computed for inputs: AirTempC = 20, p_trans = 0.95, p_humidity = 45, p_lunar_deg = 60.\n    # Calculation:\n    #   factor1 = 10 - ABS(20 - 15)/10 = 10 - 5/10 = 10 - 0.5 = 9.5\n    #   factor2 = 0.95\n    #   factor3 = 1 - 45/200 = 1 - 0.225 = 0.775\n    #   factor4 = (100 - 60)/100 = 40/100 = 0.4\n    # Expected DISF = 9.5 * 0.95 * 0.775 * 0.4 â‰ˆ 2.79775\n    expected_disf = 2.79775\n    tolerance = 0.00001  # Allowable floating-point error\n    \n    # Execute a SELECT to call calculate_disf with given parameters.\n    pred_result, _, _ = execute_queries(\"SELECT calculate_disf(20, 0.95, 45, 60);\", db_name, conn)\n    # Expecting pred_result to be a list with one tuple containing the computed value.\n    predicted_value = float(pred_result[0][0])\n    \n    # Step 3: Assert that the predicted value matches the expected DISF.\n    assert abs(predicted_value - expected_disf) < tolerance, (\n        f\"Predicted DISF value {predicted_value} differs from expected {expected_disf}\"\n    )\n    "], "category": "Management", "high_level": false, "conditions": {"decimal": -1, "distinct": false}, "amb_user_query": "Develop a PL/pgSQL routine called 'calculate_disf' that computes the sensitivity factor and return the calculated value.", "user_query_ambiguity": {"critical_ambiguity": [{"term": "routine", "sql_snippet": "CREATE OR REPLACE FUNCTION calculate_disf(", "is_mask": false, "type": "intent_ambiguity"}, {"term": "sensitivity factor", "sql_snippet": "v_disf := (10 - ABS(p_airtemp - 15)/10) * p_trans * (1 - p_humidity/200) * ((100 - p_lunar_deg)/100)", "is_mask": true, "type": "knowledge_linking_ambiguity"}], "non_critical_ambiguity": []}, "knowledge_ambiguity": [{"term": "Detection Instrument Sensitivity Factor (DISF)", "sql_snippet": "v_disf := (10 - ABS(p_airtemp - 15)/10) * p_trans * (1 - p_humidity/200) * ((100 - p_lunar_deg)/100)", "is_mask": true, "type": "knowledge_ambiguity", "deleted_knowledge": 5}], "follow_up": {"query": "Can you modify the function and add an optional minimum threshold parameter (defaulting to 0) to ensure the returned DISF value is never below this threshold?", "sol_sql": "\n    CREATE OR REPLACE FUNCTION calculate_disf(\n    p_airtemp NUMERIC, \n    p_trans NUMERIC, \n    p_humidity NUMERIC, \n    p_lunar_deg NUMERIC,\n    p_min_value NUMERIC DEFAULT 0\n) RETURNS NUMERIC AS $$\nDECLARE\n    v_disf NUMERIC;\nBEGIN\n    -- Calculate the DISF based on the given formula.\n    v_disf := (10 - ABS(p_airtemp - 15)/10) * p_trans * (1 - p_humidity/200) * ((100 - p_lunar_deg)/100);\n    \n    -- Return the maximum of calculated value or minimum threshold\n    RETURN GREATEST(v_disf, p_min_value);\nEND;\n$$ LANGUAGE plpgsql;", "external_knowledge": [], "test_cases": ["\n    def test_case(pred_sqls, sol_sqls, db_name, conn):      \n    # Test normal case\n    result1 = execute_queries(\"SELECT calculate_disf(20, 0.8, 50, 90, 5)\", db_name, conn)[0]\n    assert result1[0][0] == 5, \"Function should respect minimum threshold\"\n    \n    # Test case where calculated value is above threshold\n    result2 = execute_queries(\"SELECT calculate_disf(15, 1.0, 0, 100, -1)\", db_name, conn)[0]\n    assert result2[0][0] == 0, \"Function should return calculated value when above threshold\"\n    \n    # Test edge case\n    result3 = execute_queries(\"SELECT calculate_disf(-100, 0.1, 100, 0, 0)\", db_name, conn)[0]\n    assert result3[0][0] == 0, \"Function should handle edge cases correctly\"\n    "], "type": "constraint_change", "category": "Management"}}
